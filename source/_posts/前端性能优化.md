---
title: 前端性能优化
date: 2020-05-27 20:13:05
tags:
---
## 浏览器加载资源的过程

优化点
- dns是否可以通过缓存减少dns查询时间？
- 网络请求的过程走最近的网络环境？
- 相同的静态资源是否可以缓存？
- 能否减少请求http请求大小？
- 减少http请求
- 服务端渲染

## 资源合并与压缩

优化点：减少HTTP请求、减小请求资源的大小
- html压缩/css压缩/js的压缩和混乱/文件合并/开启gzip：html压缩效率不是很高，但css/js压缩效率是很高的。还有由于前端的源代码对于用户来说是透明的，js混乱还可以保证页面的安全性，保护业务JS逻辑

文件合并产生的问题：
- 首屏渲染问题：合并之后文件更大，加载时间更长
- 缓存失效问题：一般文件名会带一个hash标明文件内容是否改动，文件合并之后，任意一个单独文件的变动都会导致整个合并后的文件内容变化，从而导致用户缓存失效，需要重新从服务器请求文件。实际操作中一般会对不会经常变动的公共库进行合并。

浏览器并发请求数量受限于域名？？？并发数上限？
fis3 构建工具
## 图片的优化

png8/png24/png32之间的区别
- png8 —— 256色 + 支持透明  (只有256种颜色，适用于图片色彩比较单一的情况)
- png24 —— 2^24色 + 不支持透明 (支持更多的色彩，适用于图片颜色比较丰富的场景)
- png32 —— 2^24色 + 支持透明 

不同格式图片常用的业务场景
- jpg有损压缩，压缩率高，不支持透明
- png支持透明，浏览器兼容好
- webp压缩程度更好，在ios webview有兼容性问题 ：Google开发的图片格式，解码和压缩都比较快，在Android中支持比较好
- svg矢量图，代码内嵌，相对较小，图片样式相对简单的场景：内嵌HTML中，不用发起HTTP请求

CSS雪碧图
把你的网站上用到的一些图片整合到一张单独的图片中，减少你的网站的HTTP请求数量，缺点是整合的图片如果比较大，一次加载速度比较慢，如果加载失败，会导致页面上许多引用此图片的地方都产生图片失效问题。现在一般用的较少了。

Image-inline
图片内嵌，较小的图片可以转成 base-64 内嵌到HTML中，但是这会增加HTML文件的大小。

在安卓下使用webp
WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。

网站同时提供了两种类型格式的图片，后台根据浏览器是否支持webp格式进行判断，如果支持，就返回webp格式(图片较小)，如果不支持，就返回jpg格式(文件较大)
配合自动化构建工具，前端压缩 UI 提供的原始图片,前端将 png/jpg格式转成相对较小的 webp格式
在PS中合并小图标为雪碧图,借助在线网站spritecow，可以生成雪碧图的样式

在线图片压缩网站：tinypng.com
在线png/jpg转webp网站：智图 
在线雪碧图网站：www.spritecow.com

## css/js 的加载与执行
浏览器加载特点
- 顺序执行、并发加载：HTML文档从上到下采用词法分析，构建DOM树和CSSOM树，并且并发加载外部css/js资源，并发加载会受到浏览器对同一个域名资源请求数量的限制
是否阻塞
依赖关系
引入方式

CSS阻塞
css head中阻塞页面的渲染 ：会等待css加载完成
css阻塞js的执行：后续js可能会依赖css中的一些属性，所以等css加载完成之后js执行
css不阻塞外部脚本的加载

JS阻塞
直接引入的js阻塞页面的渲染
js不阻塞资源的加载 ：webkit内核中有 资源预先扫描器 ，会预先扫描后续文档中的 外链资源并加载
js顺序执行，阻塞后续js逻辑的执行 ：JS单线程从头到尾依次执行

JS引入方式
直接引入
defer
async
异步动态引入js

依赖关系
页面渲染依赖于css的加载
js的执行顺序的依赖关系
js逻辑对于dom节点的依赖关系

加载和执行的一些优化点
css 样式表置顶
用 link 代替 import
js 脚本置底
合理使用 js 的异步加载能力



## 懒加载
